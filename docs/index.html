<!DOCTYPE html>
<html>
<head>
  <title>Eclipse Airfront</title>
  <style>
   body {
  font-family: 'Press Start 2P', cursive;
     background: url('https://i.postimg.cc/nLz1zv3m/Whats-App-Image-2025-09-05-at-4-33-56-PM.jpg') no-repeat center center fixed,
                 linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                 linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
     background-size: cover, 20px 20px, 20px 20px;
     color: #00ffff; /* Neon cyan for text */
     margin: 0;
     padding: 20px;
     display: flex;
     justify-content: center;
     align-items: flex-start;
     min-height: 100vh;
     box-sizing: border-box;
    }
    #gameContainer {
      text-align: center;
      margin: 0 20px;
      position: relative;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border: 4px solid #ff00ff; /* Neon magenta border */
      border-radius: 8px;
      box-shadow: 0 0 20px #ff00ff, inset 0 0 10px #00ffff;
    }
    canvas {
      display: block;
      margin: 0 auto;
      border: 4px solid #ff00ff; /* Neon lime border */
      background: black;
      touch-action: none;
      image-rendering: pixelated; /* Pixelated effect */
      border-radius: 4px;
    }
    #waveText, #infoText, #scoreText {
      margin-top: 10px;
      font-size: 1em;
      text-shadow: 0 0 8px #ff00ff, 0 0 12px #ff00ff; /* Neon glow */
    }
    #gameOver, #gameWin {
      font-size: 2em;
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 10;
      text-shadow: 0 0 10px #ff00ff, 0 0 15px #ff00ff;
      animation: flicker 0.1s infinite alternate; /* Neon flicker effect */
    }
    @keyframes flicker {
      0% { opacity: 0.9; }
      100% { opacity: 1; }
    }
    #gameOver {
      color: #ff0000; /* Neon red */
    }
    #gameWin {
      color: #ff00ff; /* Neon lime */
    }
    button {
      margin-top: 15px;
      font-size: 1em;
      padding: 10px 20px;
      cursor: pointer;
      background: #ff00ff; /* Neon magenta */
      color: #000;
      transition: box-shadow 0.2s;
      font-family: 'Press Start 2P', cursive;
    }
    button:hover {
      box-shadow: 0 0 15px #00ffff, 0 0 20px #ff00ff;
    }
    #leaderboardContainer {
      margin: 20px;
      width: 300px;
      text-align: left;
      font-size: 0.9em;
      padding: 15px;
      background: rgba(0, 0, 0, 0.85);
      border: 3px solid #ff00ff; /* Neon lime */
      border-radius: 8px;
      box-shadow: 0 0 15px #ff00ff;
      max-height: 640px;
      overflow-y: auto;
    }
    #leaderboardContainer h2 {
      margin-top: 0;
      text-align: center;
      color: #00ffff;
      text-shadow: 0 0 8px #00ffff;
    }
    #leaderboardList li {
      padding: 8px;
      margin: 5px 0;
      background: rgba(0, 255, 255, 0.1); /* Neon cyan tint */
      border: 1px solid #ff00ff;
      border-radius: 4px;
    }
    #leaderboardList li:nth-child(odd) {
      background: rgba(255, 0, 255, 0.1); /* Neon magenta tint */
    }
    #nameInputContainer {
      margin-bottom: 20px;
      text-align: center;
    }
    #nameInput {
      font-size: 1em;
      padding: 8px;
      width: 220px;
      border-radius: 4px;
      border: 2px solid #ff00ff;
      background: rgba(0, 0, 0, 0.7);
      color: #00ffff;
      font-family: 'Press Start 2P', cursive;
    }
    #restartBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 10;
    }
    h1 {
      font-size: 1.8em;
      text-shadow: 0 0 10px #ff00ff, 0 0 15px #ff00ff;
      margin: 10px 0;
    }
    p {
      margin: 5px 0;
      font-size: 0.9em;
      text-shadow: 0 0 5px #00ffff;
    }
    @media (max-width: 900px) {
      body {
        flex-direction: column;
        align-items: center;
      }
      #leaderboardContainer {
        margin: 20px 0;
        width: 90%;
        max-width: 400px;
      }
      canvas {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <h1>[ Eclipse Airfront ]</h1>
  <p>Dev - @qazzsleeping</p>
  <p>Use Arrow To Move - Use Spacebar To Shoot !</p>

  <div id="nameInputContainer">
    <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" />
    <button id="startBtn">Start Game</button>
  </div>

  <canvas id="gameCanvas" width="480" height="640"></canvas>
  <div id="waveText">Wave: 1</div>
  <div id="infoText">Time: 0.00 s</div>
  <div id="gameOver">GAME OVER!</div>
  <div id="gameWin">YOU WIN!</div>
  <button id="restartBtn" style="display:none;">Restart Game</button>
</div>

<div id="leaderboardContainer">
  <h2>Leaderboard</h2>
  <ol id="leaderboardList">
    <!-- Leaderboard entries will appear here -->
  </ol>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const waveText = document.getElementById('waveText');
const infoText = document.getElementById('infoText');
const gameOverText = document.getElementById('gameOver');
const gameWinText = document.getElementById('gameWin');
const restartBtn = document.getElementById('restartBtn');

const nameInputContainer = document.getElementById('nameInputContainer');
const nameInput = document.getElementById('nameInput');
const startBtn = document.getElementById('startBtn');

const leaderboardList = document.getElementById('leaderboardList');

let playerName = '';
let leaderboard = [];

let player = {
  x: canvas.width/2 - 20,
  y: canvas.height - 60,
  width: 40,
  height: 50,
  speed: 6,
  movingLeft: false,
  movingRight: false,
  movingUp: false,
  movingDown: false,
  lastFireTime: 0
};

let bullets = [];
let enemies = [];
let enemyBullets = [];

const maxWave = 5;
let waveNumber = 1;
let gameOver = false;
let gameWin = false;

let startTime = null;
let elapsedTime = 0;

// Constants
const enemySpeed = 1.5;
const bulletSpeed = 12;
const enemyBulletSpeed = 4;

// Background image
const bgImage = new Image();
bgImage.src = '';

// Enemy constructor with maxHp, showHpBarTimer, zigzag, and direction properties
function createEnemy(x, y, color, big=false, hp=3, zigzag=false) {
  return {
    x, y,
    width: big ? 60 : 40,
    height: big ? 60 : 40,
    color,
    big,
    hp,
    maxHp: hp,
    alive: true,
    shootTimer: 0,
    shootInterval: big ? 120 : 200 + Math.floor(Math.random()*200),
    showHpBarTimer: 0,
    zigzag,
    direction: Math.random() > 0.5 ? 1 : -1 // Random initial direction for zigzag
  };
}

// Spawn enemies in wave according to waveNumber
function spawnWave(num) {
  enemies = [];
  enemyBullets = [];
  bullets = [];
  player.x = canvas.width/2 - player.width/2;
  player.y = canvas.height - 60;

  switch(num){
    case 1:
      for(let i=0; i<5; i++) {
        let x = canvas.width/2 + (i-2)*60;
        let y = -50 - i*40;
        enemies.push(createEnemy(x, y, '#FFD700'));
      }
      break;
    case 2:
      const centerX = canvas.width / 2;
      const startY = -60;
      const gapX = 50;
      const gapY = 50;

      for(let i = 0; i < 4; i++) {
        let y = startY + i * gapY;
        enemies.push(createEnemy(centerX - gapX * i, y, '#FF3333'));
        if(i !== 0) {
          enemies.push(createEnemy(centerX + gapX * i, y, '#FF3333'));
        }
      }
      break;
    case 3:
      for(let i=0; i<5; i++) {
        let x = canvas.width/2 - 60 + i*60;
        let y = -100 - i*60;
        enemies.push(createEnemy(x, y, '#FF3333', true, 3, true)); // Big enemies with zigzag
      }
      break;
    case 4:
      enemies.push(createEnemy(30, -60, '#FFD700'));
      enemies.push(createEnemy(canvas.width - 60, -60, '#FFD700'));
      for(let i=0; i<4; i++) {
        enemies.push(createEnemy(160 + i*40, -100 - i*30, '#FF3333'));
      }
      break;
    case 5:
      enemies.push(createEnemy(canvas.width/2 - 40, -120, '#AA0000', true, 50, true)); // Boss with zigzag
      enemies.push(createEnemy(canvas.width/2 - 120, -60, '#FF3333', false, 3, true)); // With zigzag
      enemies.push(createEnemy(canvas.width/2 + 40, -60, '#FF3333', false, 3, true)); // With zigzag
      enemies.push(createEnemy(canvas.width/2 - 160, -30, '#FF3333', false, 3, true)); // With zigzag
      enemies.push(createEnemy(canvas.width/2 + 80, -30, '#FF3333', false, 3, true)); // With zigzag
      break;
  }
}

// Player firing bullets
function firePlayerBullet() {
  if(gameOver || gameWin) return;
  if(Date.now() - player.lastFireTime < 250) return;
  player.lastFireTime = Date.now();
  bullets.push({
    x: player.x + player.width/2 -5,
    y: player.y - 10,
    width: 10,
    height: 20,
    speed: bulletSpeed
  });
}

// Enemy shooting logic
function enemyFire(enemy) {
  if(!enemy || !enemy.alive) return;
  enemyBullets.push({
    x: enemy.x + enemy.width/2 - 5,
    y: enemy.y + enemy.height,
    width: 10,
    height: 20,
    speed: enemyBulletSpeed
  });
}

// Collision detection AABB
function isColliding(a, b){
  return !(a.x + a.width < b.x || a.x > b.x + b.width || a.y + a.height < b.y || a.y > b.y + b.height);
}

// Update game each frame
function update() {
  if(gameOver || gameWin) return;

  elapsedTime = (performance.now() - startTime) / 1000;
  infoText.textContent = `Time: ${elapsedTime.toFixed(2)} s`;
  
  if(player.movingLeft) player.x -= player.speed;
  if(player.movingRight) player.x += player.speed;
  if(player.movingUp) player.y -= player.speed;
  if(player.movingDown) player.y += player.speed;

  player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
  player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));

  bullets.forEach(b => b.y -= b.speed);
  bullets = bullets.filter(b => b.y + b.height > 0);

  enemyBullets.forEach(b => b.y += b.speed);
  enemyBullets = enemyBullets.filter(b => b.y < canvas.height);

  enemies.forEach(enemy => {
    if(!enemy.alive) return;

    enemy.y += enemySpeed;

    // Logical zigzag movement: move laterally and reverse direction at edges
    if (enemy.zigzag) {
      const lateralSpeed = enemy.big ? 1.5 : 2.5; // Adjust speed based on size for logic
      enemy.x += lateralSpeed * enemy.direction;
      if (enemy.x <= 0 || enemy.x >= canvas.width - enemy.width) {
        enemy.direction = -enemy.direction;
        // Optional: slight downward boost on direction change for more dynamic movement
        enemy.y += 10;
      }
    }

    enemy.shootTimer++;
    if(enemy.shootTimer > enemy.shootInterval){
      enemy.shootTimer = 0;
      if(Math.random() < 0.5) enemyFire(enemy);
    }

    if(enemy.y > canvas.height){
      enemy.y = -enemy.height;
    }
  });

  bullets.forEach(bullet => {
    enemies.forEach(enemy => {
      if(enemy.alive && isColliding(bullet, enemy)){
        enemy.hp--;
        enemy.showHpBarTimer = 60;
        bullet.y = -100;
        if(enemy.hp <= 0){
          enemy.alive = false;
        }
      }
    });
  });

  enemies.forEach(enemy => {
    if(enemy.showHpBarTimer > 0){
      enemy.showHpBarTimer--;
    }
  });

  enemyBullets.forEach(bullet => {
    if(isColliding(bullet, player)){
      gameOver = true;
      restartBtn.style.display = 'inline-block';
      gameOverText.style.display = 'block';
    }
  });

  for(let enemy of enemies){
    if(enemy.alive && isColliding(enemy, player)){
      gameOver = true;
      restartBtn.style.display = 'inline-block';
      gameOverText.style.display = 'block';
      break;
    }
  }

  if(enemies.every(e => !e.alive)){
    if(waveNumber === maxWave){
      gameWin = true;
      restartBtn.style.display = 'inline-block';
      gameWinText.style.display = 'block';
      addToLeaderboard(playerName, elapsedTime);
    } else {
      waveNumber++;
      spawnWave(waveNumber);
      waveText.textContent = `Wave: ${waveNumber}`;
    }
  }
}

// Draw frame
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if (bgImage.complete) {
    ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
  } else {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // Player triangle with 3px stroke
  ctx.fillStyle = '#00BFFF';
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(player.x + player.width / 2, player.y);
  ctx.lineTo(player.x, player.y + player.height);
  ctx.lineTo(player.x + player.width, player.y + player.height);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#FFFF00';
  bullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));

  enemies.forEach(enemy => {
    if(enemy.alive){
      ctx.fillStyle = enemy.color;
      ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);

      if(enemy.big){
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(enemy.x, enemy.y, enemy.width, enemy.height);
      }

      if(enemy.showHpBarTimer > 0){
        const barWidth = enemy.width;
        const barHeight = 6;
        const hpRatio = enemy.hp / enemy.maxHp;
        const hpBarWidth = barWidth * hpRatio;

        ctx.fillStyle = 'gray';
        ctx.fillRect(enemy.x, enemy.y - barHeight - 2, barWidth, barHeight);

        ctx.fillStyle = 'lime';
        ctx.fillRect(enemy.x, enemy.y - barHeight - 2, hpBarWidth, barHeight);

        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(enemy.x, enemy.y - barHeight - 2, barWidth, barHeight);
      }
    }
  });

  ctx.fillStyle = '#FF4500';
  enemyBullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));
}

// Game loop
function gameLoop() {
  update();
  draw();
  if(!gameOver && !gameWin){
    requestAnimationFrame(gameLoop);
  }
}

// Add winner to leaderboard and update display
function addToLeaderboard(name, time) {
  if(!name) return;
  const existingIndex = leaderboard.findIndex(entry => entry.name === name);
  if(existingIndex !== -1){
    if(time < leaderboard[existingIndex].time){
      leaderboard[existingIndex].time = time;
    }
  } else {
    leaderboard.push({name, time});
  }
  leaderboard.sort((a,b) => a.time - b.time);
  saveLeaderboardToStorage();
  renderLeaderboard();
}

// Load leaderboard from localStorage
function loadLeaderboardFromStorage() {
  const data = localStorage.getItem('leaderboard');
  if(data){
    try {
      leaderboard = JSON.parse(data);
    } catch(e){
      leaderboard = [];
    }
  } else {
    leaderboard = [];
  }
}

// Save leaderboard to localStorage
function saveLeaderboardToStorage() {
  localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
}

// Render leaderboard
function renderLeaderboard() {
  leaderboardList.innerHTML = '';
  leaderboard.forEach((entry) => {
    const li = document.createElement('li');
    li.textContent = `${entry.name} - ${entry.time.toFixed(2)} s`;
    leaderboardList.appendChild(li);
  });
}

// Restart game
restartBtn.addEventListener('click', () => {
  restartBtn.style.display = 'none';
  gameOverText.style.display = 'none';
  gameWinText.style.display = 'none';
  waveNumber = 1;
  gameOver = false;
  gameWin = false;
  bullets = [];
  enemies = [];
  enemyBullets = [];
  player.x = canvas.width/2 - player.width/2;
  player.y = canvas.height - 60;
  startTime = performance.now();
  waveText.textContent = `Wave: ${waveNumber}`;
  infoText.textContent = `Time: 0.00 s`;
  spawnWave(waveNumber);
  gameLoop();
});

// Keyboard input (only active after game start)
document.addEventListener('keydown', e => {
  if(!startBtn.disabled) return;
  if(e.key === 'ArrowLeft') player.movingLeft = true;
  else if(e.key === 'ArrowRight') player.movingRight = true;
  else if(e.key === 'ArrowUp') player.movingUp = true;
  else if(e.key === 'ArrowDown') player.movingDown = true;
  else if(e.key === ' ') firePlayerBullet();
});

document.addEventListener('keyup', e => {
  if(!startBtn.disabled) return;
  if(e.key === 'ArrowLeft') player.movingLeft = false;
  else if(e.key === 'ArrowRight') player.movingRight = false;
  else if(e.key === 'ArrowUp') player.movingUp = false;
  else if(e.key === 'ArrowDown') player.movingDown = false;
});

// Start game only after entering name and clicking Start
startBtn.addEventListener('click', () => {
  const name = nameInput.value.trim();
  if(name.length === 0){
    alert('Please enter your name to start the game.');
    return;
  }
  playerName = name;
  nameInputContainer.style.display = 'none';
  startBtn.disabled = true;
  resetGame();
});

// Reset game function (start and restart)
function resetGame() {
  waveNumber = 1;
  gameOver = false;
  gameWin = false;
  gameOverText.style.display = 'none';
  gameWinText.style.display = 'none';
  restartBtn.style.display = 'none';
  bullets = [];
  enemies = [];
  enemyBullets = [];
  player.x = canvas.width/2 - player.width/2;
  player.y = canvas.height - 60;
  startTime = performance.now();
  spawnWave(waveNumber);
  waveText.textContent = `Wave: ${waveNumber}`;
  infoText.textContent = `Time: 0.00 s`;
  gameLoop();
}

// Initial leaderboard render
loadLeaderboardFromStorage();
renderLeaderboard();

/* === Mobile Touch Control on Canvas === */

let autoFireInterval = null;
let isDraggingPlayer = false;
let dragTouchId = null;
let touchOffsetX = 0;
let touchOffsetY = 0;

function startAutoFire() {
  if (autoFireInterval) return;
  autoFireInterval = setInterval(() => {
    firePlayerBullet();
  }, 250);
}

function stopAutoFire() {
  if (autoFireInterval) {
    clearInterval(autoFireInterval);
    autoFireInterval = null;
  }
}

function getTouchPos(touch) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top
  };
}

function isTouchOnPlayer(x, y) {
  return x >= player.x && x <= player.x + player.width
      && y >= player.y && y <= player.y + player.height;
}

canvas.addEventListener('touchstart', (e) => {
  if(gameOver || gameWin) return;
  e.preventDefault();
  for(let touch of e.changedTouches){
    const pos = getTouchPos(touch);
    if(isTouchOnPlayer(pos.x, pos.y)){
      isDraggingPlayer = true;
      dragTouchId = touch.identifier;
      touchOffsetX = pos.x - player.x;
      touchOffsetY = pos.y - player.y;
      stopAutoFire();
    } else {
      startAutoFire();
    }
  }
}, {passive:false});

canvas.addEventListener('touchmove', (e) => {
  if(gameOver || gameWin) return;
  e.preventDefault();
  if(!isDraggingPlayer) return;
  for(let touch of e.changedTouches){
    if(touch.identifier === dragTouchId){
      const pos = getTouchPos(touch);
      player.x = pos.x - touchOffsetX;
      player.y = pos.y - touchOffsetY;
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
      break;
    }
  }
}, {passive:false});

function endTouch(e){
  e.preventDefault();
  for(let touch of e.changedTouches){
    if(touch.identifier === dragTouchId){
      isDraggingPlayer = false;
      dragTouchId = null;
    }
  }
  stopAutoFire();
}

canvas.addEventListener('touchend', endTouch, {passive:false});
canvas.addEventListener('touchcancel', endTouch, {passive:false});

</script>
</body>
</html>
