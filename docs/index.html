<!DOCTYPE html>
<html>
<head>
  <title>Eclipse Airfront</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #000;
      color: white;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: 100vh;
    }
    #gameContainer {
      text-align: center;
      margin: 10px;
      position: relative;
    }
    canvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #ccc;
      background: black;
    }
    #waveText {
      margin-top: 10px;
      font-size: 1.5em;
    }
    #infoText {
      margin-top: 10px;
      font-size: 1.2em;
    }
    #gameOver, #gameWin {
      font-size: 2.5em;
      font-weight: bold;
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none; /* pastikan display diurus oleh JS */
      z-index: 10;
    }
    #gameOver {
      color: red;
    }
    #gameWin {
      color: lime;
    }
    button {
      margin-top: 15px;
      font-size: 1.2em;
      padding: 8px 16px;
      cursor: pointer;
    }
      #leaderboardContainer {
      margin-top: 105px;
      margin-bottom: 100px;
      margin-right: 150px;
      margin-left: 80px;
      width: 400px;
      text-align: left;
      font-size: 1.1em;
      padding: 10px;
      height: 640px;
      overflow-y: auto;
      box-sizing: border-box;
    }
    #leaderboardContainer h2 {
      margin-top: 0;
      text-align: center;
      color: #0f0;
    }
    #nameInputContainer {
      margin-bottom: 15px;
      text-align: center;
    }
    #nameInput {
      font-size: 1.2em;
      padding: 5px;
      width: 200px;
      border-radius: 4px;
      border: 1px solid #888;
    }
    #restartBtn {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: none; /* pastikan display diurus oleh JS */
  z-index: 10;
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <h1>[ Eclipse Airfront ]</h1>
  <p>Dev - @qazzsleeping</p>
  <p>Use Arrow To Move - Use Spacebar To Shoot !</p>

  <div id="nameInputContainer">
    <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" />
    <button id="startBtn">Start Game</button>
  </div>

  <canvas id="gameCanvas" width="480" height="640"></canvas>
  <div id="waveText">Wave: 1</div>
  <div id="infoText">Time: 0.00 s</div>
  <div id="gameOver">GAME OVER!</div>
  <div id="gameWin">YOU WIN!</div>
  <button id="restartBtn" style="display:none;">Restart Game</button>
</div>

<div id="leaderboardContainer">
  <h2>Leaderboard</h2>
  <ol id="leaderboardList">
    <!-- Leaderboard entries will appear here -->
  </ol>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const waveText = document.getElementById('waveText');
const infoText = document.getElementById('infoText');
const gameOverText = document.getElementById('gameOver');
const gameWinText = document.getElementById('gameWin');
const restartBtn = document.getElementById('restartBtn');

const nameInputContainer = document.getElementById('nameInputContainer');
const nameInput = document.getElementById('nameInput');
const startBtn = document.getElementById('startBtn');

const leaderboardList = document.getElementById('leaderboardList');

let playerName = '';
let leaderboard = [];

let player = {
  x: canvas.width/2 - 20,
  y: canvas.height - 60,
  width: 40,
  height: 50,
  speed: 6,
  movingLeft: false,
  movingRight: false,
  movingUp: false,
  movingDown: false,
  lastFireTime: 0
};

let bullets = [];
let enemies = [];
let enemyBullets = [];

const maxWave = 5;
let waveNumber = 1;
let gameOver = false;
let gameWin = false;

let startTime = null;
let elapsedTime = 0;

// Mobile touch support variables
let autoFireInterval = null;
let isDraggingPlayer = false;
let dragTouchId = null;
let touchOffsetX = 0;
let touchOffsetY = 0;

// Get game container element
const gameContainer = document.getElementById('gameContainer');

// Function to start auto firing bullets
function startAutoFire() {
  if (autoFireInterval) return; // Already firing
  autoFireInterval = setInterval(() => {
    firePlayerBullet();
  }, 250); // Fire every 250ms
}

// Function to stop auto firing bullets
function stopAutoFire() {
  if (autoFireInterval) {
    clearInterval(autoFireInterval);
    autoFireInterval = null;
  }
}

// Helper to get touch position relative to canvas
function getTouchPos(touch) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top
  };
}

// Check if position is inside player pyramid area
function isTouchOnPlayer(x, y) {
  return x >= player.x && x <= player.x + player.width
      && y >= player.y && y <= player.y + player.height;
}

// Touch start event handler
gameContainer.addEventListener('touchstart', (e) => {
  if (gameOver || gameWin) return;
  e.preventDefault();
  for (let touch of e.changedTouches) {
    const pos = getTouchPos(touch);
    if (isTouchOnPlayer(pos.x, pos.y)) {
      // Start dragging player
      isDraggingPlayer = true;
      dragTouchId = touch.identifier;
      touchOffsetX = pos.x - player.x;
      touchOffsetY = pos.y - player.y;
      stopAutoFire(); // Stop auto fire if dragging player
    } else {
      // Start auto firing bullets if touch on game container but not on player
      startAutoFire();
    }
  }
}, { passive: false });

// Touch move event handler
gameContainer.addEventListener('touchmove', (e) => {
  if (gameOver || gameWin) return;
  e.preventDefault();
  if (!isDraggingPlayer) return;
  for (let touch of e.changedTouches) {
    if (touch.identifier === dragTouchId) {
      const pos = getTouchPos(touch);
      // Move player pyramid to follow finger, constrain inside canvas
      player.x = pos.x - touchOffsetX;
      player.y = pos.y - touchOffsetY;
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
      break;
    }
  }
}, { passive: false });

// Touch end and cancel event handler
function endTouch(e) {
  e.preventDefault();
  for (let touch of e.changedTouches) {
    if (touch.identifier === dragTouchId) {
      isDraggingPlayer = false;
      dragTouchId = null;
    }
  }
  // Stop auto firing bullets when user lifts finger
  stopAutoFire();
}

gameContainer.addEventListener('touchend', endTouch, { passive: false });
gameContainer.addEventListener('touchcancel', endTouch, { passive: false });

// Constants
const enemySpeed = 1.5;
const bulletSpeed = 12;
const enemyBulletSpeed = 4;

// Enemy constructor with maxHp and showHpBarTimer properties
function createEnemy(x, y, color, big=false, hp=3) {
  return {
    x, y,
    width: big ? 60 : 40,
    height: big ? 60 : 40,
    color,
    big,
    hp,
    maxHp: hp,
    alive: true,
    shootTimer: 0,
    shootInterval: big ? 120 : 200 + Math.floor(Math.random()*200),
    showHpBarTimer: 0
  };
}

// Spawn enemies in wave according to waveNumber
function spawnWave(num) {
  enemies = [];
  enemyBullets = [];
  bullets = [];
  player.x = canvas.width/2 - player.width/2;
  player.y = canvas.height - 60;

  switch(num){
    case 1:
      for(let i=0; i<5; i++) {
        let x = canvas.width/2 + (i-2)*60;
        let y = -50 - i*40;
        enemies.push(createEnemy(x, y, '#FFD700'));
      }
      break;
    case 2:
      // Formasi V:
      // Posisi x: kiri dan kanan secara simetri, y bertambah ke bawah
      const centerX = canvas.width / 2;
      const startY = -60;
      const gapX = 50;
      const gapY = 50;

      // kiri kanan berpasangan
      for(let i = 0; i < 4; i++) {
        let y = startY + i * gapY;
        enemies.push(createEnemy(centerX - gapX * i, y, '#FF3333')); // kiri
        if(i !== 0) { // supaya titik tengah atas hanya satu musuh
          enemies.push(createEnemy(centerX + gapX * i, y, '#FF3333')); // kanan
        }
      }
      break;
    case 3:
      for(let i=0; i<5; i++) {
        let x = canvas.width/2 - 60 + i*60;
        let y = -100 - i*60;
        enemies.push(createEnemy(x, y, '#FF3333', true));
      }
      break;
    case 4:
      enemies.push(createEnemy(30, -60, '#FFD700'));
      enemies.push(createEnemy(canvas.width - 60, -60, '#FFD700'));
      for(let i=0; i<4; i++) {
        enemies.push(createEnemy(160 + i*40, -100 - i*30, '#FF3333'));
      }
      break;
    case 5:
      enemies.push(createEnemy(canvas.width/2 - 40, -120, '#AA0000', true, 50));
      enemies.push(createEnemy(canvas.width/2 - 120, -60, '#FF3333'));
      enemies.push(createEnemy(canvas.width/2 + 40, -60, '#FF3333'));
      enemies.push(createEnemy(canvas.width/2 - 160, -30, '#FF3333'));
      enemies.push(createEnemy(canvas.width/2 + 80, -30, '#FF3333'));
      break;
  }
}

// Player firing bullets
function firePlayerBullet() {
  if(gameOver || gameWin) return;
  if(Date.now() - player.lastFireTime < 250) return;
  player.lastFireTime = Date.now();
  bullets.push({
    x: player.x + player.width/2 -5,
    y: player.y - 10,
    width: 10,
    height: 20,
    speed: bulletSpeed
  });
}

// Enemy shooting logic
function enemyFire(enemy) {
  if(!enemy || !enemy.alive) return;
  enemyBullets.push({
    x: enemy.x + enemy.width/2 - 5,
    y: enemy.y + enemy.height,
    width: 10,
    height: 20,
    speed: enemyBulletSpeed
  });
}

// Collision detection AABB
function isColliding(a, b){
  return !(a.x + a.width < b.x || a.x > b.x + b.width || a.y + a.height < b.y || a.y > b.y + b.height);
}

// Update game each frame
function update() {
  if(gameOver || gameWin) return;

  // Timer update
  elapsedTime = (performance.now() - startTime) / 1000;
  infoText.textContent = `Time: ${elapsedTime.toFixed(2)} s`;

  // Player move
  if(player.movingLeft) player.x -= player.speed;
  if(player.movingRight) player.x += player.speed;
  if(player.movingUp) player.y -= player.speed;
  if(player.movingDown) player.y += player.speed;

  player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
  player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));

  // Update player's bullets
  bullets.forEach(b => b.y -= b.speed);
  bullets = bullets.filter(b => b.y + b.height > 0);

  // Update enemies' bullets
  enemyBullets.forEach(b => b.y += b.speed);
  enemyBullets = enemyBullets.filter(b => b.y < canvas.height);

  // Update enemies movement and shooting
  enemies.forEach(enemy => {
    if(!enemy.alive) return;

    enemy.y += enemySpeed;

    enemy.shootTimer++;
    if(enemy.shootTimer > enemy.shootInterval){
      enemy.shootTimer = 0;
      if(Math.random() < 0.5) enemyFire(enemy);
    }

    if(enemy.y > canvas.height){
      enemy.y = -enemy.height;
    }
  });

  // Bullet hits enemy
  bullets.forEach(bullet => {
    enemies.forEach(enemy => {
      if(enemy.alive && isColliding(bullet, enemy)){
        enemy.hp--;
        enemy.showHpBarTimer = 60;
        bullet.y = -100;
        if(enemy.hp <= 0){
          enemy.alive = false;
        }
      }
    });
  });

  // Decrease HP bar timer for enemies
  enemies.forEach(enemy => {
    if(enemy.showHpBarTimer > 0){
      enemy.showHpBarTimer--;
    }
  });

  // Enemy bullet hits player
  enemyBullets.forEach(bullet => {
    if(isColliding(bullet, player)){
      gameOver = true;
      restartBtn.style.display = 'inline-block';
      gameOverText.style.display = 'block';
    }
  });

  // Player collides enemy → game over immediately
  for(let enemy of enemies){
    if(enemy.alive && isColliding(enemy, player)){
      gameOver = true;
      restartBtn.style.display = 'inline-block';
      gameOverText.style.display = 'block';
      break;
    }
  }

  // Check if all enemies dead → next wave (if not last wave)
  if(enemies.every(e => !e.alive)){
    if(waveNumber === maxWave){
      gameWin = true;
      restartBtn.style.display = 'inline-block';
      gameWinText.style.display = 'block';
      addToLeaderboard(playerName, elapsedTime);
    } else {
      waveNumber++;
      spawnWave(waveNumber);
      waveText.textContent = `Wave: ${waveNumber}`;
    }
  }
}

// Draw frame
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Player triangle
  ctx.fillStyle = '#00BFFF';
  ctx.beginPath();
  ctx.moveTo(player.x + player.width / 2, player.y); // Top center
  ctx.lineTo(player.x, player.y + player.height);    // Bottom left
  ctx.lineTo(player.x + player.width, player.y + player.height); // Bottom right
  ctx.closePath();
  ctx.fill();
  // Player bullets
  ctx.fillStyle = '#FFFF00';
  bullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));

  // Enemies
  enemies.forEach(enemy => {
    if(enemy.alive){
      ctx.fillStyle = enemy.color;
      ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);

      if(enemy.big){
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(enemy.x, enemy.y, enemy.width, enemy.height);
      }

      // Draw HP bar if showHpBarTimer active
      if(enemy.showHpBarTimer > 0){
        const barWidth = enemy.width;
        const barHeight = 6;
        const hpRatio = enemy.hp / enemy.maxHp;
        const hpBarWidth = barWidth * hpRatio;

        ctx.fillStyle = 'gray';
        ctx.fillRect(enemy.x, enemy.y - barHeight - 2, barWidth, barHeight);

        ctx.fillStyle = 'lime';
        ctx.fillRect(enemy.x, enemy.y - barHeight - 2, hpBarWidth, barHeight);

        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.strokeRect(enemy.x, enemy.y - barHeight - 2, barWidth, barHeight);
      }
    }
  });

  // Enemy bullets
  ctx.fillStyle = '#FF4500';
  enemyBullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));
}

// Game loop
function gameLoop() {
  update();
  draw();
  if(!gameOver && !gameWin){
    requestAnimationFrame(gameLoop);
  }
}

// Add winner to leaderboard and update display
function addToLeaderboard(name, time) {
  if(!name) return;
  leaderboard.push({name, time});
  // Sort ascending by time (fastest first)
  leaderboard.sort((a,b) => a.time - b.time);
  renderLeaderboard();
}

// Load leaderboard from localStorage on page load
function loadLeaderboardFromStorage() {
  const data = localStorage.getItem('leaderboard');
  if(data){
    try {
      leaderboard = JSON.parse(data);
    } catch(e){
      leaderboard = [];
    }
  } else {
    leaderboard = [];
  }
}

// Save leaderboard array to localStorage
function saveLeaderboardToStorage() {
  localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
}

// Add or update player score in leaderboard
function addToLeaderboard(name, time) {
  if(!name) return;
  // Check if player already exists
  const existingIndex = leaderboard.findIndex(entry => entry.name === name);
  if(existingIndex !== -1){
    // Update time if new time is better (smaller)
    if(time < leaderboard[existingIndex].time){
      leaderboard[existingIndex].time = time;
    }
  } else {
    // Add new player
    leaderboard.push({name, time});
  }
  // Sort by time ascending
  leaderboard.sort((a,b) => a.time - b.time);

  // Save to localStorage
  saveLeaderboardToStorage();

  // Render updated leaderboard
  renderLeaderboard();
}

// Render leaderboard in the list element
function renderLeaderboard() {
  leaderboardList.innerHTML = '';
  leaderboard.forEach((entry) => {
    const li = document.createElement('li');
    li.textContent = `${entry.name} - ${entry.time.toFixed(2)} s`;
    leaderboardList.appendChild(li);
  });
}

// Restart game logic
restartBtn.addEventListener('click', () => {
  restartBtn.style.display = 'none';
  gameOverText.style.display = 'none';
  gameWinText.style.display = 'none';
  waveNumber = 1;
  gameOver = false;
  gameWin = false;
  bullets = [];
  enemies = [];
  enemyBullets = [];
  player.x = canvas.width/2 - player.width/2;
  player.y = canvas.height - 60;
  startTime = performance.now();
  waveText.textContent = `Wave: ${waveNumber}`;
  infoText.textContent = `Time: 0.00 s`;
  spawnWave(waveNumber);
  gameLoop();
});

// Keyboard input (only active after game start)
document.addEventListener('keydown', e => {
  if(!startBtn.disabled){
    // Ignore input before game starts
    return;
  }
  if(e.key === 'ArrowLeft') player.movingLeft = true;
  else if(e.key === 'ArrowRight') player.movingRight = true;
  else if(e.key === 'ArrowUp') player.movingUp = true;
  else if(e.key === 'ArrowDown') player.movingDown = true;
  else if(e.key === ' ') firePlayerBullet();
});

document.addEventListener('keyup', e => {
  if(!startBtn.disabled){
    return;
  }
  if(e.key === 'ArrowLeft') player.movingLeft = false;
  else if(e.key === 'ArrowRight') player.movingRight = false;
  else if(e.key === 'ArrowUp') player.movingUp = false;
  else if(e.key === 'ArrowDown') player.movingDown = false;
});

// Start game only after entering a name and clicking Start
startBtn.addEventListener('click', () => {
  const name = nameInput.value.trim();
  if(name.length === 0){
    alert('Please enter your name to start the game.');
    return;
  }
  playerName = name;
  nameInputContainer.style.display = 'none';
  startBtn.disabled = true;
  resetGame();
});

// Reset game function (called on start and restart)
function resetGame() {
  waveNumber = 1;
  gameOver = false;
  gameWin = false;
  gameOverText.style.display = 'none';
  gameWinText.style.display = 'none';
  restartBtn.style.display = 'none';
  bullets = [];
  enemies = [];
  enemyBullets = [];
  player.x = canvas.width/2 - player.width/2;
  player.y = canvas.height - 60;
  startTime = performance.now();
  spawnWave(waveNumber);
  waveText.textContent = `Wave: ${waveNumber}`;
  infoText.textContent = `Time: 0.00 s`;
  gameLoop();
}

// Initial leaderboard render (empty)
// On page load, load leaderboard from localStorage and render
loadLeaderboardFromStorage();
renderLeaderboard();


</script>
</body>
</html>