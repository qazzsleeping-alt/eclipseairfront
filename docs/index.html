<!DOCTYPE html>
<html>
<head>
  <title>Eclipse Airfront</title>
  <style>
   body {
  font-family: 'Press Start 2P', cursive;
     background: url('https://i.postimg.cc/nLz1zv3m/Whats-App-Image-2025-09-05-at-4-33-56-PM.jpg') no-repeat center center fixed,
                 linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                 linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
     background-size: cover, 20px 20px, 20px 20px;
     color: #00ffff; /* Default neon cyan for text */
     margin: 0;
     padding: 20px;
     display: flex;
     justify-content: center;
     align-items: flex-start;
     min-height: 100vh;
     box-sizing: border-box;
    }
    #gameContainer {
      text-align: center;
      margin: 0 20px;
      position: relative;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border: 4px solid #ff00ff; /* Default neon magenta border */
      border-radius: 8px;
      box-shadow: 0 0 20px #ff00ff, inset 0 0 10px #00ffff; /* Default neon glow */
    }
    canvas {
      display: block;
      margin: 0 auto;
      border: 4px solid #ff00ff; /* Default neon lime border */
      background: black;
      touch-action: none;
      image-rendering: pixelated; /* Pixelated effect */
      border-radius: 4px;
    }
    #infoText, #scoreText {
      margin-top: 10px;
      font-size: 1em;
      text-shadow: 0 0 8px #ff00ff, 0 0 12px #ff00ff; /* Default neon glow */
    }
    #gameOver, #gameWin {
      font-size: 2em;
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 10;
      text-shadow: 0 0 10px #ff00ff, 0 0 15px #ff00ff; /* Default neon glow */
      animation: flicker 0.1s infinite alternate; /* Neon flicker effect */
    }
    #gameOver {
      color: #ff0000; /* Neon red for game over */
    }
    #gameWin {
      color: #00ff00; /* Neon green for win */
    }
    @keyframes flicker {
      0% { opacity: 0.9; }
      100% { opacity: 1; }
    }
    button {
      margin-top: 15px;
      font-size: 1em;
      padding: 10px 20px;
      cursor: pointer;
      background: #ff00ff; /* Default neon magenta */
      color: #000;
      transition: box-shadow 0.2s;
      font-family: 'Press Start 2P', cursive;
    }
    button:hover {
      box-shadow: 0 0 15px #00ffff, 0 0 20px #ff00ff; /* Default neon glow */
    }
    #leaderboardContainer {
      margin: 20px;
      width: 300px;
      text-align: left;
      font-size: 0.9em;
      padding: 15px;
      background: rgba(0, 0, 0, 0.85);
      border: 3px solid #ff00ff; /* Default neon lime */
      border-radius: 8px;
      box-shadow: 0 0 15px #ff00ff; /* Default neon glow */
    }
    #leaderboardContainer h2 {
      margin-top: 0;
      text-align: center;
      color: #00ffff; /* Default neon cyan */
      text-shadow: 0 0 8px #00ffff; /* Default neon glow */
    }
    #leaderboardList li {
      padding: 8px;
      margin: 5px 0;
      background: rgba(0, 255, 255, 0.1); /* Neon cyan tint */
      border: 1px solid #ff00ff;
      border-radius: 4px;
    }
    #leaderboardList li:nth-child(odd) {
      background: rgba(255, 0, 255, 0.1); /* Neon magenta tint */
    }
    #nameInputContainer {
      margin-bottom: 20px;
      text-align: center;
    }
    #nameInput {
      font-size: 1em;
      padding: 8px;
      width: 220px;
      border-radius: 4px;
      border: 2px solid #ff00ff; /* Default neon magenta */
      background: rgba(0, 0, 0, 0.7);
      color: #00ffff; /* Default neon cyan */
      font-family: 'Press Start 2P', cursive;
    }
    #restartBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 10;
    }
    h1 {
      font-size: 1.8em;
      text-shadow: 0 0 10px #ff00ff, 0 0 15px #ff00ff; /* Default neon glow */
      margin: 10px 0;
    }
    p {
      margin: 5px 0;
      font-size: 0.9em;
      text-shadow: 0 0 5px #00ffff; /* Default neon glow */
    }
    @media (max-width: 900px) {
      body {
        flex-direction: column;
        align-items: center;
      }
      #leaderboardContainer {
        margin: 20px 0;
        width: 90%;
        max-width: 400px;
      }
      canvas {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <h1>Eclipse Airfront</h1>
  <p>Dev - @qazzsleeping</p>
  <p>Use Arrow Keys To Move - Use Spacebar To Shoot!</p>

  <div id="nameInputContainer">
    <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" />
    <button id="startBtn">Start Game</button>
  </div>

  <canvas id="gameCanvas" width="480" height="640"></canvas>
  <div id="scoreText">Score: 0</div>
  <div id="infoText">Time: 0.00 s</div>
  <div id="gameOver">GAME OVER!</div>
  <div id="gameWin">YOU WIN!</div>
  <button id="restartBtn" style="display:none;">Restart Game</button>
</div>

<div id="leaderboardContainer">
  <h2>Leaderboard</h2>
  <ol id="leaderboardList">
    <!-- Leaderboard entries will appear here -->
  </ol>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const scoreText = document.getElementById('scoreText');
const infoText = document.getElementById('infoText');
const gameOverText = document.getElementById('gameOver');
const gameWinText = document.getElementById('gameWin');
const restartBtn = document.getElementById('restartBtn');

const nameInputContainer = document.getElementById('nameInputContainer');
const nameInput = document.getElementById('nameInput');
const startBtn = document.getElementById('startBtn');

const leaderboardList = document.getElementById('leaderboardList');

let playerName = '';
let leaderboard = [];

let player = {
  x: canvas.width / 2 - 20,
  y: canvas.height - 60,
  width: 40,
  height: 50,
  speed: 6,
  movingLeft: false,
  movingRight: false,
  lastFireTime: 0
};

let bullets = [];
let enemies = [];
let score = 0;
let stars = 0;
let gameOver = false;
let gameWon = false;
let startTime = null;
let elapsedTime = 0;
let neonColor = '#ff00ff'; // Default neon magenta

// Enemy constructor
function createEnemy() {
  return {
    x: Math.random() * (canvas.width - 40),
    y: -40,
    width: 40,
    height: 40,
    color: '#FF3333',
    alive: true
  };
}

// Spawn enemies randomly
function spawnEnemy() {
  let spawnChance = 0.02; // Base 2% chance
  if (stars >= 3) spawnChance = 0.06; // 6% for 3 stars (tripled)
  else if (stars >= 2) spawnChance = 0.04; // 4% for 2 stars (doubled)
  if (Math.random() < spawnChance) {
    enemies.push(createEnemy());
  }
}

// Player firing bullets
function firePlayerBullet() {
  if (gameOver || gameWon) return;
  if (Date.now() - player.lastFireTime < 200) return;
  player.lastFireTime = Date.now();
  bullets.push({
    x: player.x + player.width / 2 - 5,
    y: player.y - 10,
    width: 10,
    height: 20,
    speed: 7
  });
}

// Collision detection AABB
function isColliding(a, b) {
  return !(a.x + a.width < b.x || a.x > b.x + b.width || a.y + a.height < b.y || a.y > b.y + b.height);
}

// Draw a star
function drawStar(x, y, size) {
  ctx.fillStyle = '#FFFF00';
  ctx.beginPath();
  for (let i = 0; i < 5; i++) {
    const angle = Math.PI / 2.5 * i - Math.PI / 2;
    const radius = i % 2 === 0 ? size : size / 2;
    ctx.lineTo(
      x + radius * Math.cos(angle),
      y + radius * Math.sin(angle)
    );
  }
  ctx.closePath();
  ctx.fill();
}

// Update neon colors
function updateNeonColors() {
  if (stars === 3) {
    neonColor = '#FFFFFF'; // White for 3 stars
  } else if (stars === 2) {
    neonColor = '#FF0000'; // Red for 2 stars
  } else if (stars === 1) {
    neonColor = '#00FFFF'; // Cyan for 1 star
  } else {
    neonColor = '#FF00FF'; // Magenta for 0 stars
  }

  const gameContainer = document.getElementById('gameContainer');
  const leaderboardContainer = document.getElementById('leaderboardContainer');
  const canvasElement = document.getElementById('gameCanvas');
  const nameInputElement = document.getElementById('nameInput');
  const startBtnElement = document.getElementById('startBtn');
  const restartBtnElement = document.getElementById('restartBtn');
  const h1 = gameContainer.querySelector('h1');
  const ps = gameContainer.querySelectorAll('p');
  const leaderboardH2 = leaderboardContainer.querySelector('h2');

  // Update borders and glow
  gameContainer.style.borderColor = neonColor;
  gameContainer.style.boxShadow = `0 0 20px ${neonColor}, inset 0 0 10px ${neonColor}`;
  canvasElement.style.borderColor = neonColor;
  leaderboardContainer.style.borderColor = neonColor;
  leaderboardContainer.style.boxShadow = `0 0 15px ${neonColor}`;
  nameInputElement.style.borderColor = neonColor;
  startBtnElement.style.backgroundColor = neonColor;
  restartBtnElement.style.backgroundColor = neonColor;
  startBtnElement.style.boxShadow = `0 0 15px ${neonColor}, 0 0 20px ${neonColor}`;
  restartBtnElement.style.boxShadow = `0 0 15px ${neonColor}, 0 0 20px ${neonColor}`;

  // Update text colors and shadows
  h1.style.color = neonColor;
  h1.style.textShadow = `0 0 10px ${neonColor}, 0 0 15px ${neonColor}`;
  ps.forEach(p => {
    p.style.color = neonColor;
    p.style.textShadow = `0 0 5px ${neonColor}`;
  });
  scoreText.style.color = neonColor;
  scoreText.style.textShadow = `0 0 8px ${neonColor}, 0 0 12px ${neonColor}`;
  infoText.style.color = neonColor;
  infoText.style.textShadow = `0 0 8px ${neonColor}, 0 0 12px ${neonColor}`;
  gameOverText.style.textShadow = `0 0 10px ${neonColor}, 0 0 15px ${neonColor}`;
  gameWinText.style.textShadow = `0 0 10px ${neonColor}, 0 0 15px ${neonColor}`;
  leaderboardH2.style.color = neonColor;
  leaderboardH2.style.textShadow = `0 0 8px ${neonColor}`;
}

// Update game each frame
function update() {
  if (gameOver || gameWon) return;

  elapsedTime = (performance.now() - startTime) / 1000;
  infoText.textContent = `Time: ${elapsedTime.toFixed(2)} s`;

  // Update stars based on score
  if (score >= 1000) {
    stars = 3;
    gameWon = true;
    gameWinText.style.display = 'block';
    restartBtn.style.display = 'inline-block';
    addToLeaderboard(playerName, score, stars);
  } else if (score >= 500) {
    stars = 3;
  } else if (score >= 400) {
    stars = 2;
  } else if (score >= 200) {
    stars = 1;
  } else {
    stars = 0;
  }

  // Update enemy speed based on stars
  let effectiveEnemySpeed = 3; // Default for 0 stars
  if (stars === 1) effectiveEnemySpeed = 5;
  else if (stars === 2) effectiveEnemySpeed = 7;
  else if (stars === 3) effectiveEnemySpeed = 10;

  // Move player
  if (player.movingLeft) player.x -= player.speed;
  if (player.movingRight) player.x += player.speed;
  player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));

  // Update player bullets
  bullets.forEach(b => b.y -= b.speed);
  bullets = bullets.filter(b => b.y + b.height > 0);

  // Spawn and update enemies
  spawnEnemy();
  enemies = enemies.filter(enemy => enemy.y < canvas.height);
  enemies.forEach(enemy => {
    if (!enemy.alive) return;
    enemy.y += effectiveEnemySpeed;

    // Check collision with player
    if (isColliding(player, enemy)) {
      gameOver = true;
      restartBtn.style.display = 'inline-block';
      gameOverText.style.display = 'block';
      addToLeaderboard(playerName, score, stars);
    }

    // Check collision with player bullets
    bullets.forEach((bullet, bulletIndex) => {
      if (isColliding(bullet, enemy)) {
        enemy.alive = false;
        bullets.splice(bulletIndex, 1);
        score += 10;
        scoreText.textContent = `Score: ${score}`;
      }
    });
  });
}

// Draw frame
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw background
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw player (triangle with stroke)
  ctx.fillStyle = '#00BFFF';
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(player.x + player.width / 2, player.y);
  ctx.lineTo(player.x, player.y + player.height);
  ctx.lineTo(player.x + player.width, player.y + player.height);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Draw player bullets
  ctx.fillStyle = '#FFFF00';
  bullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));

  // Draw enemies
  ctx.fillStyle = '#FF3333';
  enemies.forEach(enemy => {
    if (enemy.alive) {
      ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
    }
  });

  // Draw stars
  for (let i = 0; i < stars; i++) {
    drawStar(10 + i * 30, 30, 10);
  }
}

// Game loop
function gameLoop() {
  update();
  updateNeonColors(); // Update neon colors each frame
  draw();
  if (!gameOver && !gameWon) {
    requestAnimationFrame(gameLoop);
  }
}

// Add to leaderboard and update display
function addToLeaderboard(name, score, stars) {
  if (!name) return;
  const existingIndex = leaderboard.findIndex(entry => entry.name === name);
  if (existingIndex !== -1) {
    if (score > leaderboard[existingIndex].score) {
      leaderboard[existingIndex].score = score;
      leaderboard[existingIndex].stars = stars;
    }
  } else {
    leaderboard.push({ name, score, stars });
  }
  leaderboard.sort((a, b) => b.score - a.score);
  saveLeaderboardToStorage();
  renderLeaderboard();
}

// Load leaderboard from localStorage
function loadLeaderboardFromStorage() {
  const data = localStorage.getItem('leaderboard');
  if (data) {
    try {
      leaderboard = JSON.parse(data);
    } catch (e) {
      leaderboard = [];
    }
  } else {
    leaderboard = [];
  }
}

// Save leaderboard to localStorage
function saveLeaderboardToStorage() {
  localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
}

// Render leaderboard
function renderLeaderboard() {
  leaderboardList.innerHTML = '';
  leaderboard.forEach((entry) => {
    const li = document.createElement('li');
    li.textContent = `${entry.name} - ${entry.score} (${entry.stars || 0}â˜…)`;
    leaderboardList.appendChild(li);
  });
}

// Restart game
restartBtn.addEventListener('click', () => {
  restartBtn.style.display = 'none';
  gameOverText.style.display = 'none';
  gameWinText.style.display = 'none';
  score = 0;
  stars = 0;
  gameOver = false;
  gameWon = false;
  bullets = [];
  enemies = [];
  neonColor = '#ff00ff'; // Reset neon color
  player.x = canvas.width / 2 - player.width / 2;
  player.y = canvas.height - 60;
  startTime = performance.now();
  scoreText.textContent = `Score: ${score}`;
  infoText.textContent = `Time: 0.00 s`;
  gameLoop();
});

// Keyboard input (only active after game start)
document.addEventListener('keydown', e => {
  if (!startBtn.disabled) return;
  if (e.key === 'ArrowLeft') player.movingLeft = true;
  else if (e.key === 'ArrowRight') player.movingRight = true;
  else if (e.key === ' ') firePlayerBullet();
});

document.addEventListener('keyup', e => {
  if (!startBtn.disabled) return;
  if (e.key === 'ArrowLeft') player.movingLeft = false;
  else if (e.key === 'ArrowRight') player.movingRight = false;
});

// Start game only after entering name and clicking Start
startBtn.addEventListener('click', () => {
  const name = nameInput.value.trim();
  if (name.length === 0) {
    alert('Please enter your name to start the game.');
    return;
  }
  playerName = name;
  nameInputContainer.style.display = 'none';
  startBtn.disabled = true;
  resetGame();
});

// Reset game function
function resetGame() {
  score = 0;
  stars = 0;
  gameOver = false;
  gameWon = false;
  gameOverText.style.display = 'none';
  gameWinText.style.display = 'none';
  restartBtn.style.display = 'none';
  bullets = [];
  enemies = [];
  neonColor = '#ff00ff'; // Reset neon color
  player.x = canvas.width / 2 - player.width / 2;
  player.y = canvas.height - 60;
  startTime = performance.now();
  scoreText.textContent = `Score: ${score}`;
  infoText.textContent = `Time: 0.00 s`;
  gameLoop();
}

// Initial leaderboard render
loadLeaderboardFromStorage();
renderLeaderboard();

/* === Mobile Touch Control on Canvas === */

let autoFireInterval = null;
let isDraggingPlayer = false;
let dragTouchId = null;
let touchOffsetX = 0;

function startAutoFire() {
  if (autoFireInterval) return;
  autoFireInterval = setInterval(() => {
    firePlayerBullet();
  }, 200);
}

function stopAutoFire() {
  if (autoFireInterval) {
    clearInterval(autoFireInterval);
    autoFireInterval = null;
  }
}

function getTouchPos(touch) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top
  };
}

function isTouchOnPlayer(x, y) {
  return x >= player.x && x <= player.x + player.width &&
         y >= player.y && y <= player.y + player.height;
}

canvas.addEventListener('touchstart', (e) => {
  if (gameOver || gameWon) return;
  e.preventDefault();
  for (let touch of e.changedTouches) {
    const pos = getTouchPos(touch);
    if (isTouchOnPlayer(pos.x, pos.y)) {
      isDraggingPlayer = true;
      dragTouchId = touch.identifier;
      touchOffsetX = pos.x - player.x;
      stopAutoFire();
    } else {
      startAutoFire();
    }
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  if (gameOver || gameWon) return;
  e.preventDefault();
  if (!isDraggingPlayer) return;
  for (let touch of e.changedTouches) {
    if (touch.identifier === dragTouchId) {
      const pos = getTouchPos(touch);
      player.x = pos.x - touchOffsetX;
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      break;
    }
  }
}, { passive: false });

function endTouch(e) {
  e.preventDefault();
  for (let touch of e.changedTouches) {
    if (touch.identifier === dragTouchId) {
      isDraggingPlayer = false;
      dragTouchId = null;
    }
  }
  stopAutoFire();
}

canvas.addEventListener('touchend', endTouch, { passive: false });
canvas.addEventListener('touchcancel', endTouch, { passive: false });

</script>
</body>
</html>
