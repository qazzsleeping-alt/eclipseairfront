<!DOCTYPE html>
<html>
<head>
  <title>Eclipse Airfront</title>
  <style>
   body {
  font-family: 'Press Start 2P', cursive;
     background: url('https://i.postimg.cc/nLz1zv3m/Whats-App-Image-2025-09-05-at-4-33-56-PM.jpg') no-repeat center center fixed,
                 linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                 linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
     background-size: cover, 20px 20px, 20px 20px;
     color: #00ffff; /* Default neon cyan for text */
     margin: 0;
     padding: 20px;
     display: flex;
     justify-content: center;
     align-items: flex-start;
     min-height: 100vh;
     box-sizing: border-box;
    }
    #gameContainer {
      text-align: center;
      margin: 0 20px;
      position: relative;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border: 4px solid #ff00ff; /* Default neon magenta border */
      border-radius: 8px;
      box-shadow: 0 0 20px #ff00ff, inset 0 0 10px #00ffff; /* Default neon glow */
    }
    canvas {
      display: block;
      margin: 0 auto;
      border: 4px solid #ff00ff; /* Default neon lime border */
      background: black;
      touch-action: none;
      image-rendering: pixelated; /* Pixelated effect */
      border-radius: 4px;
    }
    #infoText, #scoreText {
      margin-top: 10px;
      font-size: 1em;
      text-shadow: 0 0 8px #ff00ff, 0 0 12px #ff00ff; /* Default neon glow */
    }
    #gameOver, #gameWin {
      font-size: 2em;
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 10;
      text-shadow: 0 0 10px #ff00ff, 0 0 15px #ff00ff; /* Default neon glow */
      animation: flicker 0.1s infinite alternate; /* Neon flicker effect */
    }
    #gameOver {
      color: #ff0000; /* Neon red for game over */
    }
    #gameWin {
      color: #00ff00; /* Neon green for win */
    }
    @keyframes flicker {
      0% { opacity: 0.9; }
      100% { opacity: 1; }
    }
    button {
      margin: 10px 5px;
      font-size: 1em;
      padding: 10px 20px;
      cursor: pointer;
      background: #ff00ff; /* Default neon magenta */
      color: #000;
      transition: box-shadow 0.2s;
      font-family: 'Press Start 2P', cursive;
      border-radius: 4px;
      border: 2px solid #00ffff;
    }
    button:hover {
      box-shadow: 0 0 15px #00ffff, 0 0 20px #ff00ff; /* Default neon glow */
    }
    #leaderboardContainer {
      margin: 20px;
      width: 300px;
      text-align: left;
      font-size: 0.9em;
      padding: 15px;
      background: rgba(0, 0, 0, 0.85);
      border: 3px solid #ff00ff; /* Default neon lime */
      border-radius: 8px;
      box-shadow: 0 0 15px #ff00ff; /* Default neon glow */
    }
    #leaderboardContainer h2 {
      margin-top: 0;
      text-align: center;
      color: #00ffff; /* Default neon cyan */
      text-shadow: 0 0 8px #00ffff; /* Default neon glow */
    }
    #leaderboardList li {
      padding: 8px;
      margin: 5px 0;
      background: rgba(0, 255, 255, 0.1); /* Neon cyan tint */
      border: 1px solid #ff00ff;
      border-radius: 4px;
    }
    #leaderboardList li:nth-child(odd) {
      background: rgba(255, 0, 255, 0.1); /* Neon magenta tint */
    }
    #nameInputContainer {
      margin-bottom: 20px;
      text-align: center;
    }
    #nameInput {
      font-size: 1em;
      padding: 8px;
      width: 220px;
      border-radius: 4px;
      border: 2px solid #ff00ff; /* Default neon magenta */
      background: rgba(0, 0, 0, 0.7);
      color: #00ffff; /* Default neon cyan */
      font-family: 'Press Start 2P', cursive;
    }
    #restartBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 10;
    }
    h1 {
      font-size: 1.8em;
      text-shadow: 0 0 10px #ff00ff, 0 0 15px #ff00ff; /* Default neon glow */
      margin: 10px 0;
    }
    p {
      margin: 5px 0;
      font-size: 0.9em;
      text-shadow: 0 0 5px #00ffff; /* Default neon glow */
    }
    @media (max-width: 900px) {
      body {
        flex-direction: column;
        align-items: center;
      }
      #leaderboardContainer {
        margin: 20px 0;
        width: 90%;
        max-width: 400px;
      }
      canvas {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <h1>Eclipse Airfront</h1>
  <p>Dev - @qazzsleeping</p>
  <p>Use Arrow Keys To Move - Hold Spacebar To Autofire!</p>

  <div id="nameInputContainer">
    <input type="text" id="nameInput" placeholder="Enter your name" maxlength="20" />
    <button id="startBtn">Start Game</button>
  </div>

  <canvas id="gameCanvas" width="480" height="640"></canvas>
  <div id="scoreText">Score: 0</div>
  <div id="infoText">Time: 0.00 s</div>
  <div id="gameOver">GAME OVER!</div>
  <div id="gameWin">YOU WIN!</div>
  <button id="restartBtn" style="display:none;">Restart Game</button>
</div>

<div id="leaderboardContainer">
  <h2>Leaderboard</h2>
  <button id="clearLeaderboardBtn">Clear Leaderboard</button>
  <ol id="leaderboardList">
    <!-- Leaderboard entries will appear here -->
  </ol>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const scoreText = document.getElementById('scoreText');
const infoText = document.getElementById('infoText');
const gameOverText = document.getElementById('gameOver');
const gameWinText = document.getElementById('gameWin');
const restartBtn = document.getElementById('restartBtn');
const clearLeaderboardBtn = document.getElementById('clearLeaderboardBtn');

const nameInputContainer = document.getElementById('nameInputContainer');
const nameInput = document.getElementById('nameInput');
const startBtn = document.getElementById('startBtn');

const leaderboardList = document.getElementById('leaderboardList');

let playerName = '';
let leaderboard = [];

let player = {
  x: canvas.width / 2 - 20,
  y: canvas.height - 60,
  width: 40,
  height: 50,
  speed: 6,
  movingLeft: false,
  movingRight: false,
  lastFireTime: 0
};

let bullets = [];
let enemies = [];
let particles = [];
let scorePopups = [];
let score = 0;
let stars = 0;
let gameOver = false;
let gameWon = false;
let startTime = null;
let elapsedTime = 0;
let neonColor = '#4300FF'; // Default neon color for 0 stars

// Audio elements
const backgroundMusic = new Audio('');
backgroundMusic.loop = true;
const enemyDeathSound = new Audio('https://www.myinstants.com/media/sounds/pixel-gun-3d-royal-revolver.mp3');
const gameOverSound = new Audio('https://www.myinstants.com/media/sounds/game-over-end-pixel-b-side.mp3');

// Load player and enemy images
const playerImg = new Image();
playerImg.src = 'https://i.postimg.cc/4Nc1v58D/gg-removebg-preview.png';

const enemyImg = new Image();
enemyImg.src = 'https://i.postimg.cc/GpGQKpgc/hmmmmmmmmmm-removebg-preview.png';

// Keyboard autofire
let keyboardAutoFireInterval = null;
let isSpaceHeld = false;

// Particle constructor for 8-bit explosion effect
function createParticle(x, y) {
  return {
    x: x,
    y: y,
    size: Math.random() * 5 + 3, // Random size between 3 and 8
    vx: (Math.random() - 0.5) * 8, // Random velocity x
    vy: (Math.random() - 0.5) * 8, // Random velocity y
    color: ['#FF0000', '#FFFF00', '#00FF00', '#00FFFF'][Math.floor(Math.random() * 4)], // Random neon color
    life: 30 // Frames to live
  };
}

// Score popup constructor for "+10" text
function createScorePopup(x, y) {
  return {
    x: x,
    y: y,
    text: '+10',
    alpha: 1,
    life: 60 // Frames to live
  };
}

// Enemy constructor
function createEnemy() {
  return {
    x: Math.random() * (canvas.width - 40),
    y: -40,
    width: 40,
    height: 40,
    color: '#FF3333',
    alive: true
  };
}

// Spawn enemies randomly
function spawnEnemy() {
  let spawnChance = 0.04; // Base 2% chance
  if (stars === 3) spawnChance = 0.12; // 6% for 3 stars (tripled)
  else if (stars === 2) spawnChance = 0.08; // 4% for 2 stars (doubled)
  if (Math.random() < spawnChance) {
    enemies.push(createEnemy());
  }
}

// Player firing bullets
function firePlayerBullet() {
  if (gameOver || gameWon) return;
  if (Date.now() - player.lastFireTime < 180) return;
  player.lastFireTime = Date.now();
  bullets.push({
    x: player.x + player.width / 2 - 5,
    y: player.y - 10,
    width: 8,
    height: 20,
    speed: 9 // Increased bullet speed
  });
}

// Start keyboard autofire
function startKeyboardAutoFire() {
  if (keyboardAutoFireInterval) return;
  keyboardAutoFireInterval = setInterval(() => {
    firePlayerBullet();
  }, 200);
}

// Stop keyboard autofire
function stopKeyboardAutoFire() {
  if (keyboardAutoFireInterval) {
    clearInterval(keyboardAutoFireInterval);
    keyboardAutoFireInterval = null;
  }
}

// Collision detection AABB
function isColliding(a, b) {
  return !(a.x + a.width < b.x || a.x > b.x + b.width || a.y + a.height < b.y || a.y > b.y + b.height);
}

// Draw a star
function drawStar(x, y, size) {
  ctx.fillStyle = '#FFFF00';
  ctx.beginPath();
  for (let i = 0; i < 5; i++) {
    const angle = Math.PI / 2.5 * i - Math.PI / 2;
    const radius = i % 2 === 0 ? size : size / 2;
    ctx.lineTo(
      x + radius * Math.cos(angle),
      y + radius * Math.sin(angle)
    );
  }
  ctx.closePath();
  ctx.fill();
}

// Update neon colors
function updateNeonColors() {
  if (score >= 1200) {
    neonColor = '#F0F3FF'; // Light blue for score >= 1200
  } else if (stars === 3) {
    neonColor = '#FF004D'; // Red for 3 stars
  } else if (stars === 2) {
    neonColor = '#00CAFF'; // Cyan for 2 stars
  } else if (stars === 1) {
    neonColor = '#0065F8'; // Blue for 1 star
  } else {
    neonColor = '#4300FF'; // Purple for 0 stars
  }

  const gameContainer = document.getElementById('gameContainer');
  const leaderboardContainer = document.getElementById('leaderboardContainer');
  const canvasElement = document.getElementById('gameCanvas');
  const nameInputElement = document.getElementById('nameInput');
  const startBtnElement = document.getElementById('startBtn');
  const restartBtnElement = document.getElementById('restartBtn');
  const clearLeaderboardBtnElement = document.getElementById('clearLeaderboardBtn');
  const h1 = gameContainer.querySelector('h1');
  const ps = gameContainer.querySelectorAll('p');
  const leaderboardH2 = leaderboardContainer.querySelector('h2');

  // Update borders and glow
  gameContainer.style.borderColor = neonColor;
  gameContainer.style.boxShadow = `0 0 20px ${neonColor}, inset 0 0 10px ${neonColor}`;
  canvasElement.style.borderColor = neonColor;
  leaderboardContainer.style.borderColor = neonColor;
  leaderboardContainer.style.boxShadow = `0 0 15px ${neonColor}`;
  nameInputElement.style.borderColor = neonColor;
  startBtnElement.style.backgroundColor = neonColor;
  restartBtnElement.style.backgroundColor = neonColor;
  clearLeaderboardBtnElement.style.backgroundColor = neonColor;
  startBtnElement.style.boxShadow = `0 0 15px ${neonColor}, 0 0 20px ${neonColor}`;
  restartBtnElement.style.boxShadow = `0 0 15px ${neonColor}, 0 0 20px ${neonColor}`;
  clearLeaderboardBtnElement.style.boxShadow = `0 0 15px ${neonColor}, 0 0 20px ${neonColor}`;

  // Update text colors and shadows
  h1.style.color = neonColor;
  h1.style.textShadow = `0 0 10px ${neonColor}, 0 0 15px ${neonColor}`;
  ps.forEach(p => {
    p.style.color = neonColor;
    p.style.textShadow = `0 0 5px ${neonColor}`;
  });
  scoreText.style.color = neonColor;
  scoreText.style.textShadow = `0 0 8px ${neonColor}, 0 0 12px ${neonColor}`;
  infoText.style.color = neonColor;
  infoText.style.textShadow = `0 0 8px ${neonColor}, 0 0 12px ${neonColor}`;
  gameOverText.style.textShadow = `0 0 10px ${neonColor}, 0 0 15px ${neonColor}`;
  gameWinText.style.textShadow = `0 0 10px ${neonColor}, 0 0 15px ${neonColor}`;
  leaderboardH2.style.color = neonColor;
  leaderboardH2.style.textShadow = `0 0 8px ${neonColor}`;
}

// Update game each frame
function update() {
  if (gameOver || gameWon) return;

  elapsedTime = (performance.now() - startTime) / 1000;
  infoText.textContent = `Time: ${elapsedTime.toFixed(2)} s`;

  // Update stars based on score
  if (score >= 1500) {
    stars = 3;
    gameWon = true;
    gameWinText.style.display = 'block';
    restartBtn.style.display = 'inline-block';
    addToLeaderboard(playerName, score, stars);
  } else if (score >= 900) {
    stars = 3;
  } else if (score >= 600) {
    stars = 2;
  } else if (score >= 300) {
    stars = 1;
  } else {
    stars = 0;
  }

  // Update enemy speed based on stars
  let effectiveEnemySpeed = 3; // Default for 0 stars
  if (stars === 1) effectiveEnemySpeed = 5;
  else if (stars === 2) effectiveEnemySpeed = 7;
  else if (stars === 3) effectiveEnemySpeed = 10;

  // Move player
  if (player.movingLeft) player.x -= player.speed;
  if (player.movingRight) player.x += player.speed;
  player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));

  // Update player bullets
  bullets.forEach(b => b.y -= b.speed);
  bullets = bullets.filter(b => b.y + b.height > 0);

  // Update particles
  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
  });
  particles = particles.filter(p => p.life > 0);

  // Update score popups
  scorePopups.forEach(p => {
    p.y -= 1; // Move upward
    p.alpha -= 1 / p.life; // Fade out
    p.life--;
  });
  scorePopups = scorePopups.filter(p => p.life > 0);

  // Spawn and update enemies
  spawnEnemy();
  enemies = enemies.filter(enemy => enemy.y < canvas.height);
  enemies.forEach(enemy => {
    if (!enemy.alive) return;
    enemy.y += effectiveEnemySpeed;

    // Check collision with player
    if (isColliding(player, enemy)) {
      gameOver = true;
      backgroundMusic.pause();
      backgroundMusic.currentTime = 0;
      gameOverSound.play().catch(e => console.error('Error playing game over sound:', e));
      restartBtn.style.display = 'inline-block';
      gameOverText.style.display = 'block';
      addToLeaderboard(playerName, score, stars);
    }

    // Check collision with player bullets
    bullets.forEach((bullet, bulletIndex) => {
      if (isColliding(bullet, enemy)) {
        enemy.alive = false;
        bullets.splice(bulletIndex, 1);
        score += 10;
        scoreText.textContent = `Score: ${score}`;
        // Create particles
        for (let i = 0; i < 10; i++) {
          particles.push(createParticle(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2));
        }
        // Create score popup
        scorePopups.push(createScorePopup(enemy.x + enemy.width / 2, enemy.y));
        // Play enemy death sound (create new Audio instance to avoid cooldown)
        const deathSound = new Audio('https://www.myinstants.com/media/sounds/pixel-gun-3d-royal-revolver.mp3');
        deathSound.play().catch(e => console.error('Error playing enemy death sound:', e));
      }
    });
  });
}

// Draw frame
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw background
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw player using image
  if (playerImg.complete && playerImg.naturalHeight !== 0) {
    ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
  } else {
    // Fallback to original triangle if image not loaded
    ctx.fillStyle = '#00BFFF';
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(player.x + player.width / 2, player.y);
    ctx.lineTo(player.x, player.y + player.height);
    ctx.lineTo(player.x + player.width, player.y + player.height);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  // Draw player bullets
  ctx.fillStyle = '#FFFF00';
  bullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));

  // Draw enemies using image
  if (enemyImg.complete && enemyImg.naturalHeight !== 0) {
    enemies.forEach(enemy => {
      if (enemy.alive) {
        ctx.drawImage(enemyImg, enemy.x, enemy.y, enemy.width, enemy.height);
      }
    });
  } else {
    // Fallback to original rectangle if image not loaded
    ctx.fillStyle = '#FF3333';
    enemies.forEach(enemy => {
      if (enemy.alive) {
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
      }
    });
  }

  // Draw particles
  particles.forEach(p => {
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  });

  // Draw score popups
  scorePopups.forEach(p => {
    ctx.fillStyle = `rgba(255, 255, 0, ${p.alpha})`;
    ctx.font = '16px "Press Start 2P"';
    ctx.textAlign = 'center';
    ctx.fillText(p.text, p.x, p.y);
  });

  // Draw stars
  for (let i = 0; i < stars; i++) {
    drawStar(10 + i * 30, 30, 10);
  }
}

// Game loop
function gameLoop() {
  update();
  updateNeonColors(); // Update neon colors each frame
  draw();
  if (!gameOver && !gameWon) {
    requestAnimationFrame(gameLoop);
  }
}

// Add to leaderboard and update display
function addToLeaderboard(name, score, stars) {
  if (!name || name.trim() === '') {
    console.error('Cannot add to leaderboard: Player name is empty');
    return;
  }
  const cleanName = name.trim().toLowerCase();
  const existingIndex = leaderboard.findIndex(entry => entry.name.toLowerCase() === cleanName);
  if (existingIndex !== -1) {
    // Update only if new score is higher
    if (score > leaderboard[existingIndex].score) {
      leaderboard[existingIndex].score = score;
      leaderboard[existingIndex].stars = stars;
      console.log(`Updated score for ${name}: ${score} with ${stars} stars`);
    }
  } else {
    // Add new entry even if player loses
    leaderboard.push({ name: name.trim(), score, stars });
    console.log(`Added new score for ${name}: ${score} with ${stars} stars`);
  }
  // Sort leaderboard by score in descending order
  leaderboard.sort((a, b) => b.score - a.score);
  // Limit leaderboard to top 10 entries
  if (leaderboard.length > 10) {
    leaderboard = leaderboard.slice(0, 10);
  }
  try {
    saveLeaderboardToStorage();
    renderLeaderboard();
  } catch (e) {
    console.error('Failed to save or render leaderboard:', e);
  }
}

// Load leaderboard from localStorage
function loadLeaderboardFromStorage() {
  try {
    const data = localStorage.getItem('leaderboard');
    if (data) {
      leaderboard = JSON.parse(data);
      if (!Array.isArray(leaderboard)) {
        console.error('Invalid leaderboard data, resetting to empty array');
        leaderboard = [];
      }
    } else {
      leaderboard = [];
    }
    renderLeaderboard();
  } catch (e) {
    console.error('Failed to load leaderboard from localStorage:', e);
    leaderboard = [];
    renderLeaderboard();
  }
}

// Save leaderboard to localStorage
function saveLeaderboardToStorage() {
  try {
    localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
  } catch (e) {
    console.error('Failed to save leaderboard to localStorage:', e);
  }
}

// Render leaderboard
function renderLeaderboard() {
  leaderboardList.innerHTML = '';
  leaderboard.forEach((entry, index) => {
    if (entry.name && entry.score >= 0) {
      const li = document.createElement('li');
      li.textContent = `${entry.name} - ${entry.score} (${entry.stars || 0}★)`;
      leaderboardList.appendChild(li);
    }
  });
}

// Clear leaderboard
clearLeaderboardBtn.addEventListener('click', () => {
  if (confirm('Are you sure you want to clear the leaderboard? This cannot be undone.')) {
    localStorage.removeItem('leaderboard');
    leaderboard = [];
    renderLeaderboard();
    console.log('Leaderboard cleared');
  }
});

// Restart game
restartBtn.addEventListener('click', () => {
  restartBtn.style.display = 'none';
  gameOverText.style.display = 'none';
  gameWinText.style.display = 'none';
  score = 0;
  stars = 0;
  gameOver = false;
  gameWon = false;
  bullets = [];
  enemies = [];
  particles = [];
  scorePopups = [];
  neonColor = '#4300FF'; // Reset neon color to 0 stars
  player.x = canvas.width / 2 - player.width / 2;
  player.y = canvas.height - 60;
  startTime = performance.now();
  scoreText.textContent = `Score: ${score}`;
  infoText.textContent = `Time: 0.00 s`;
  stopKeyboardAutoFire(); // Stop any ongoing autofire
  backgroundMusic.play().catch(e => console.error('Error playing background music:', e));
  gameLoop();
});

// Keyboard input (only active after game start)
document.addEventListener('keydown', e => {
  if (!startBtn.disabled) return;
  if (e.key === 'ArrowLeft') player.movingLeft = true;
  else if (e.key === 'ArrowRight') player.movingRight = true;
  else if (e.key === ' ') {
    e.preventDefault(); // Prevent space from scrolling
    if (!isSpaceHeld) {
      isSpaceHeld = true;
      startKeyboardAutoFire();
    }
  }
});

document.addEventListener('keyup', e => {
  if (!startBtn.disabled) return;
  if (e.key === 'ArrowLeft') player.movingLeft = false;
  else if (e.key === 'ArrowRight') player.movingRight = false;
  else if (e.key === ' ') {
    isSpaceHeld = false;
    stopKeyboardAutoFire();
  }
});

// Start game only after entering name and clicking Start
startBtn.addEventListener('click', () => {
  const name = nameInput.value.trim();
  if (name.length === 0) {
    alert('Please enter your name to start the game.');
    return;
  }
  playerName = name;
  nameInputContainer.style.display = 'none';
  startBtn.disabled = true;
  backgroundMusic.play().catch(e => console.error('Error playing background music:', e));
  resetGame();
});

// Reset game function
function resetGame() {
  score = 0;
  stars = 0;
  gameOver = false;
  gameWon = false;
  gameOverText.style.display = 'none';
  gameWinText.style.display = 'none';
  restartBtn.style.display = 'none';
  bullets = [];
  enemies = [];
  particles = [];
  scorePopups = [];
  neonColor = '#4300FF'; // Reset neon color to 0 stars
  player.x = canvas.width / 2 - player.width / 2;
  player.y = canvas.height - 60;
  startTime = performance.now();
  scoreText.textContent = `Score: ${score}`;
  infoText.textContent = `Time: 0.00 s`;
  isSpaceHeld = false;
  stopKeyboardAutoFire(); // Ensure autofire is stopped
  gameLoop();
}

// Initial leaderboard render
loadLeaderboardFromStorage();

// Mobile Touch Control on Canvas
let autoFireInterval = null;
let isDraggingPlayer = false;
let dragTouchId = null;
let touchOffsetX = 0;

function startAutoFire() {
  if (autoFireInterval) return;
  autoFireInterval = setInterval(() => {
    firePlayerBullet();
  }, 200);
}

function stopAutoFire() {
  if (autoFireInterval) {
    clearInterval(autoFireInterval);
    autoFireInterval = null;
  }
}

function getTouchPos(touch) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top
  };
}

function isTouchOnPlayer(x, y) {
  return x >= player.x && x <= player.x + player.width &&
         y >= player.y && y <= player.y + player.height;
}

canvas.addEventListener('touchstart', (e) => {
  if (gameOver || gameWon) return;
  e.preventDefault();
  for (let touch of e.changedTouches) {
    const pos = getTouchPos(touch);
    if (isTouchOnPlayer(pos.x, pos.y)) {
      isDraggingPlayer = true;
      dragTouchId = touch.identifier;
      touchOffsetX = pos.x - player.x;
      startAutoFire(); // Start autofire when dragging player
    } else {
      startAutoFire();
    }
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  if (gameOver || gameWon) return;
  e.preventDefault();
  if (!isDraggingPlayer) return;
  for (let touch of e.changedTouches) {
    if (touch.identifier === dragTouchId) {
      const pos = getTouchPos(touch);
      player.x = pos.x - touchOffsetX;
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      break;
    }
  }
}, { passive: false });

function endTouch(e) {
  e.preventDefault();
  for (let touch of e.changedTouches) {
    if (touch.identifier === dragTouchId) {
      isDraggingPlayer = false;
      dragTouchId = null;
    }
  }
  stopAutoFire();
}

canvas.addEventListener('touchend', endTouch, { passive: false });
canvas.addEventListener('touchcancel', endTouch, { passive: false });
</script>
</body>
</html>
